<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      /*
        函数
        一、函数的概念
            把完成特定功能的一段代码（抽象出来），使之成为程序中的一个（独立实体），起个名字（函数名）。
            可以在同一个程序或其他程序中多次重复使用（通过函数名调用） 
        二、函数的语法：
            1.函数声明【注】见名思意，函数名必须体现其功能
                <1>无参数无返回值的函数
                    function 函数名(){
                        函数体(具体要求执行的代码);
                    }
                <2>有参数无返回值的函数
                    function 函数名(形参1，形参2...){
                        函数体;
                    }
                <3>有参数有返回值的函数
                    function 函数名(形参1,形参2...){
                        函数体;
                        return 表达式;
                    }
                    【注】
                        1.return后面写什么表达式，函数调用的结果就是return后面表达式的值
                        2.函数运行的时候，如果遇到return关键字，整个函数会终止
                    
            2.函数调用(和 1.函数声明 对应)
                格式：
                    <1>函数名();
                    <2>函数名(实参1,实参2...);//传参：用实参给形参赋值
        三、函数的作用
            1.使程序变得简短而清晰
            2.有利于程序的维护
            3.可以提升程序开发的效率
            4.提高了代码的重用性（复用性）
        四、封装函数的步骤
            1.分析不确定值
            2.将不确定值声明成形参
            3.函数名和形参名都要见名思意
            【注】封装函数时，每一个函数内部都有一个arguments，系统内置的
                arguments是用来存储实际传入的参数
            arguments属性：
                arguments.length    输出当前里面存储的参数个数
            访问某一个数据：
                arguments[下标];(下标从0开始)
        五、函数作用域
            任何程序在执行的时候都要占用内存空间，函数调用的时候也要去占用内存空间
            【注】在函数内部声明的变量和形参是属于当前函数的内存空间里的
            垃圾回收机制：调用函数的时候，系统会分配对应的空间给这个函数使用。
                        当函数使用完毕后，这个内存空间要释放，还给系统
            内存管理机制：在函数中声明的变量和形参，会随着函数的调用被创建，随着函数的调用结束而被销毁
                        在函数中声明变量和形参，有效范围是当前函数（作用域）
        六、递归
            满足以下三个特点就是递归：
                1.函数自己调用自己
                2.一般情况下有参数
                3.一般情况下有return
            【注】递归可以解决循环能做的所有事情，一些循环不容易解决的事情，递归也能轻松解决
                 递归，都可以写出来，但不知道为什么是对的
            递归编写方法：
                1.首先去找临界值，即无需计算，获得的值
                2.找这一次和上一次的关系
                3.假设当前函数已经可以使用，调用自身计算上一次
         */
    </script>
    <script>
      //函数封装的练习

      //编写一个函数，计算两个数字的和、差、积、商
      function operation(num1, operator, num2) {
        //operator根据运算符的符号，进行不同的运算
        switch (operator) {
          case "+":
            return num1 + num2;
            break;
          case "-":
            return num1 - num2;
            break;
          case "*":
            return num1 * num2;
            break;
          case "/":
            return num1 / num2;
            break;
          default:
            alert("Error");
            break;
        }
      }
      var result = operation(3, "+", 5);
      console.log(result);

      //编写一个函数，当n为偶数时，求1/2+1/4+...+1/n,当n为奇数时，求1+1/3+1/5+...+1/n
      function sum(n) {
        var result = 0;
        if (n % 2 == 0) {
          for (var i = 2; i <= n; i += 2) {
            result += 1 / i;
          }
        } else {
          for (var i = 1; i <= n; i += 2) {
            result += 1 / i;
          }
        }
        return result;
      }
      var rst = sum(4);
      console.log(rst);

      //函数递归练习

      //递归，计算1-n的和
      function sum(n) {
        if (n == 1) {
          return 1;
        }
        return sum(n - 1) + n;
      }
      alert(sum(100));

      //斐波那契数列
      function rabbit(n) {
        if (n < 4) {
          return 1;
        }
        return rabbit(n - 1) + rabbit(n - 3);
      }
      alert(rabbit(9));

      /*递归（猴子吃桃）
        有一堆猴子不知数目，猴子第一天吃掉一半，觉得不过瘾，又多吃了一只，第二天照此办法，吃掉了剩下桃子
        的一半多一只，天天如此，到第num（num<=10)天早上，猴子发现只剩下一只桃子了，问这堆桃子原来有多
        少只？
       */
      function peach(n) {
        if (n == 1) {
          return 1;
        }
        return (peach(n - 1) + 1) * 2;
      }
      alert(peach(4));
    </script>
  </head>
  <body></body>
</html>
